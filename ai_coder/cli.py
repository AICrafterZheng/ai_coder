import ast
import astor
import argparse
import os
from ai_coder.file_utils import read_file, write_file
import importlib
import inspect
from ai_coder.logger import logger
from typing import List, Dict
from ai_coder.code_utils import review_code, print_help_info_to_console
from ai_coder.llm_client import generate_func, CodeModel, call_llm
import json

class AICoder:
    def __init__(self) -> None:
        self.tree = None
        self.prompt_map = {}
        self.new_prompt_map = {}
        self.isForceUpdate = False
        self.out_path = None
        self.existing_tree = None

    def gen_code(self, filePath: str, isForceUpdate: bool = False) -> None:
        self.isForceUpdate = isForceUpdate

        # Write the new code to a file
        directories = filePath.split(os.sep)
        out_dir = f"./{os.sep.join(directories[1:len(directories)-1])}"
        logger.info(f"out_dir: {out_dir}")
        if not os.path.exists(out_dir):
            os.makedirs(out_dir, exist_ok=True)

        out_path = f"./{os.sep.join(directories[1:])}"
        self.out_path = out_path
        logger.info(f"Generating code from {filePath} to {out_path}...")
        if os.path.exists(out_path):
            existing_code = read_file(out_path)
            if existing_code.strip() != "":
                self.existing_tree = ast.parse(existing_code)

        code = read_file(filePath)
        self.tree = ast.parse(code)

        # Load the lock file or create an empty dictionary if it doesn't exist
        lock_file_path = filePath + ".lock"
        if os.path.exists(lock_file_path):
            with open(lock_file_path, 'r') as f:
                self.prompt_map: Dict[str, str] = json.load(f)
        else:
            self.prompt_map = {}
        self.new_prompt_map = {}

        # for node in ast.walk(self.tree):
        for node in self.tree.body:
            if isinstance(node, ast.ClassDef):
                for sub_node in node.body:
                    if isinstance(sub_node, ast.FunctionDef) and self.has_ai_code_decorator(sub_node):
                        self.prompt_to_code(sub_node)
            elif isinstance(node, ast.FunctionDef) and self.has_ai_code_decorator(node):
                self.prompt_to_code(node)

        save_code = astor.to_source(self.tree)
        logger.info(f"Code to save: {save_code}")
        write_file(out_path, save_code)
        review_code(out_path)
        logger.info("Finished generating the code!")
        save_code = read_file(out_path)
        save_code = f"###This file is generated by AI from {filePath}. DO NOT MODIFY THIS FILE MANUALLY###\n\n{save_code}"
        write_file(out_path, save_code)
        print_help_info_to_console(save_code)

        # Save the updated prompt map to the lock file
        with open(lock_file_path, 'w') as f:
            json.dump(self.new_prompt_map, f, indent=4)

    def has_ai_code_decorator(self, node: ast.FunctionDef) -> bool:
        if not hasattr(node, 'decorator_list'):
            return False
        for decorator in node.decorator_list:
            if isinstance(decorator, ast.Name) and decorator.id == 'ai_code':
                logger.info(f"Function {node.name} has the ai_code decorator.")
                return True
        logger.info(f"Function {node.name} does not have the ai_code decorator.")
        return False
    
    def prompt_to_code(self, node: ast.FunctionDef):
        logger.info(f"prompt_to_code called with {node.name}")
        if self.isForceUpdate:
            logger.info(f"Force updating the function {node.name}...")
            # Update the prompt map
            self.new_prompt_map[node.name] = self.get_prompt(node)
            new_body = self.get_function_implementation(node)
            self.replace_function_implementation(node, node.name, new_body)
            logger.info(f"Saving the generated code to {self.out_path}.")
        elif self.is_function_prompt_updated(node, self.prompt_map):
            logger.info(f"Prompt updated for the function {node.name}...")
            # Update the prompt map
            self.new_prompt_map[node.name] = self.get_prompt(node)
            new_body = self.get_function_implementation(node)
            self.replace_function_implementation(node, node.name, new_body)
            logger.info(f"Saving the generated code to {self.out_path}.")
        elif self.existing_tree and self.is_function_generated(self.existing_tree, node.name):
            logger.info(f"Function {node.name} is already generated. Reusing the existing code...")
            self.new_prompt_map[node.name] = self.prompt_map.get(node.name, self.get_prompt(node))
            new_body = self.get_function_from_tree(self.existing_tree, node.name).body
            self.replace_function_implementation(node, node.name, new_body)
        else:
            logger.info(f"Generating code for the function {node.name}...")
            # Update the prompt map
            self.new_prompt_map[node.name] = self.get_prompt(node)
            new_body = self.get_function_implementation(node)
            self.replace_function_implementation(node, node.name, new_body)
            logger.info(f"Saving the generated code to {self.out_path}.")

    def is_function_prompt_updated(self, function: ast.FunctionDef, prompt_map: Dict[str, str]) -> bool:
        current_prompt = self.get_prompt(function)
        return function.name in prompt_map and prompt_map[function.name] != current_prompt

    def is_function_defined(self, function: str) -> bool:
        for node in ast.walk(self.tree):
            if isinstance(node, ast.FunctionDef) and node.name == function:
                return True
        return False
    
    def is_function_generated(self, tree: ast.AST, function: str) -> bool:
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name == function:
                return True
        return False

    def get_function_from_tree(self, tree: ast.AST, function_name: str) -> ast.FunctionDef:
        logger.info(f"Getting function {function_name} from the tree...")
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name == function_name:
                return node
        return ast.FunctionDef()

    def get_function_f_string_info(self, function_def: ast.FunctionDef) -> str:
        # Find the f-string node within the function body
        f_string_node = None
        for node in ast.walk(function_def):
            if isinstance(node, ast.JoinedStr):
                f_string_node = node
                break
        if f_string_node:
            # Get the f-string
            f_string = ast.unparse(f_string_node)
            # Find the formatted values in the f-string
            formatted_values = []
            for value in f_string_node.values:
                if isinstance(value, ast.FormattedValue):
                    formatted_values.append(ast.unparse(value.value))

            # Check if any formatted value is a global variable or function and get its information for LLM to use
            for value in formatted_values:
                try:
                    if self.is_variable_defined(value):
                        f_string += f"\n The variable: {value} is already defined, you can just use it."
                    else:
                        signature = self.get_function_signature(value)
                        f_string += f" The function {value} is ready to use, and has signature {signature}. You can just call it."
                except NameError as e:
                    logger.error(f"Function '{value}' error: {e}")
            return f_string
        else:
            logger.warning("F-string not found in the function.")
            return ""

    def get_function_signature(self, function_name: str) -> str:
        logger.info(f"Getting signature for function {function_name}")
        # Get function signature from the import statement
        for node in ast.walk(self.tree):
            if isinstance(node, ast.ImportFrom):
                for alias in node.names:
                    if alias.name == function_name:
                        logger.info(f"Function {function_name} is imported. Checking the signature...")
                        # Import the module containing the function
                        module_name = node.module
                        module = importlib.import_module(module_name)
                        # Get the imported function
                        imported_function = getattr(module, alias.name)
                        # Get the function signature
                        signature = inspect.signature(imported_function)
                        logger.info(f"{function_name} is imported, signature: {signature}")
                        return  str(signature)
        # Get function signature from the function definition
        for node in ast.walk(self.tree):
            if isinstance(node, ast.FunctionDef) and node.name == function_name:
                logger.info(f"Function {function_name} is defined. Checking the signature...")
                # Get the function arguments
                args = [arg.arg for arg in node.args.args]
                # Get the function return type
                if isinstance(node.returns, ast.Name):
                    return_type = node.returns.id
                elif isinstance(node.returns, ast.Constant):
                    return_type = node.returns.value
                else:
                    return_type = None
                sig = f"({', '.join(args)}) -> {return_type}"
                logger.info(f"{function_name} is defined, got signature: {sig}")
                return sig
        return ""

    def is_variable_defined(self, variable_name: str) -> bool:
        for node in ast.walk(self.tree):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id == variable_name:
                        return True
        return False

    def get_prompt(self, function_def: ast.FunctionDef) -> str:
        logger.info(f"Getting prompt for function {function_def.name}...")
        logger.info(f"{ast.dump(function_def)}")
        # Get the function docstring
        docstring = ast.get_docstring(function_def)
        if docstring:
            logger.info(f"Function {function_def.name} docstring prompt: {docstring}")
            return docstring
        logger.warning(f"Function {function_def.name} docstring not found.")
        f_string = self.get_function_f_string_info(function_def)
        if f_string:
            logger.info(f"Function {function_def.name} f_string prompt: {f_string}")
            return f_string
        logger.warning(f"Function {function_def.name} prompt not found.")
        return ""

    def get_function_implementation(self, node: ast.FunctionDef) -> List[ast.AST]:
        """
        Call LLM to generate the implementation for a given function.
        """
        # Extract the description from the return statement
        prompt = self.get_prompt(node)
        sig = self.get_function_signature(node.name)
        prompt += f"\n the Python function signature is '{node.name}: {sig}', please refer to the signature to generate the code, but don't include the signature in the code."
        prompt += " Please import any necessary modules."
        logger.info(f"The prompt to generate the code for function {node.name}: {prompt}")
        code_model: CodeModel = generate_func(prompt)
        logger.info(f"generated_code: {code_model}")
        # Replace the function body with the generated code
        func_body = code_model.func_body
        if func_body.startswith('    '):# Fix error "IndentationError: unexpected indent"
            func_body = '\n'.join(line[4:] if line.startswith('    ') else line for line in func_body.split('\n'))
        new_body = ast.parse(func_body).body
        logger.info(f"New body: {new_body}")
        return new_body

    def replace_function_implementation(self, tree: ast.AST, function_name: str, new_body: List[ast.AST]) -> ast.AST:
        class ReplaceFunction(ast.NodeTransformer):
            def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:
                if node.name == function_name:
                    # Replace the function body
                    node.body = new_body
                    # Fix missing locations in the new function body
                    ast.fix_missing_locations(node)
                return node
        transformer = ReplaceFunction()
        new_tree_list = transformer.visit(tree)
        return new_tree_list

def main() -> None:
    # Create the parser
    parser = argparse.ArgumentParser(description='AI Coder Tool')
    subparsers = parser.add_subparsers(dest='command')

    # Subcommand: gen_code
    parser_gen_code = subparsers.add_parser('gen', help='Generate code from a file')
    parser_gen_code.add_argument('filepath', type=str, help='The file to generate code from')
    parser_gen_code.add_argument('--force', action='store_true', help='Force code generation even if the prompt is unchanged')

    args = parser.parse_args()
    logger.info(f"args: {args}")
    if args.command == 'gen':
        ai_coder = AICoder()
        ai_coder.gen_code(args.filepath, args.force)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()